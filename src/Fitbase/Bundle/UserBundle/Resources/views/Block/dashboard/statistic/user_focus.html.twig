<div class="panel panel-default">
    <div class="panel-body">

        <h4 class="short hue">
            {{ 'Fokus'|trans({}, 'FitbaseUserBundle') }}
        </h4>


        <div id="statistic_user_focus">
            <svg id="pieChartSVG">
                <defs>
                    <filter id='pieChartInsetShadow'>
                        <feOffset dx='0' dy='0'/>
                        <feGaussianBlur stdDeviation='3' result='offset-blur'/>
                        <feComposite operator='out' in='SourceGraphic' in2='offset-blur' result='inverse'/>
                        <feFlood flood-color='black' flood-opacity='1' result='color'/>
                        <feComposite operator='in' in='color' in2='inverse' result='shadow'/>
                        <feComposite operator='over' in='shadow' in2='SourceGraphic'/>
                    </filter>
                    <filter id="pieChartDropShadow">
                        <feGaussianBlur in="SourceAlpha" stdDeviation="3" result="blur"/>
                        <feOffset in="blur" dx="0" dy="3" result="offsetBlur"/>
                        <feMerge>
                            <feMergeNode/>
                            <feMergeNode in="SourceGraphic"/>
                        </feMerge>
                    </filter>
                </defs>
            </svg>
        </div>


        {% if categories is defined and categories %}
            <div class="row">
                <table class="table table-striped table-hover table-responsive">
                    <tbody>
                    {% for category in categories %}
                        <tr>
                            </td>
                            <td class="shade">
                                {% thumbnail category.category.media, 'icon' with { "width": "50px" } %}
                                {{ category }}
                            </td>
                            <td class="shade">
                                {{ category.countUser }}
                            </td>
                        </tr>
                    {% endfor %}
                    </tbody>
                </table>
            </div>
        {% endif %}

    </div>
</div>

<script type="text/javascript">


    $(function () {

        (function (selector) {


            var containerEl = $(selector).get(0);

            var width = containerEl.clientWidth,
                    height = width / 2,
                    radius = Math.min(width, height) / 2.5;


            var svg = d3.select(selector).select("svg")
                    .style("width", width + "px")
                    .style("height", height + "px")
                    .append("g")

            svg.append("g").attr("class", "slices");
            svg.append("g").attr("class", "labels");
            svg.append("g").attr("class", "lines");

            var pie = d3.layout.pie()
                    .value(function (d) {
                        return d.value;
                    });

            var arc = d3.svg.arc()
                    .outerRadius(radius * 0.8)
                    .innerRadius(radius * 0.4);

            var outerArc = d3.svg.arc()
                    .innerRadius(radius * 0.9)
                    .outerRadius(radius * 0.9);

            svg.attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

            var key = function (d) {
                return d.data.label;
            };


            var weights = [];
            var categories = [];
            {% if categories is defined and categories %}
            {% for category in categories %}
            weights.push('{{ category.countUser }}');
            categories.push('{{ category }}');
            {% endfor %}
            {% endif %}


            var color = d3.scale.ordinal()
                    .domain(categories)
                    .range(["#a2d049", "#397bc9", "#7b6888", "#6b486b", "#a05d56", "#d0743c", "#ff8c00"]);

            var weight = d3.scale.ordinal()
                    .domain(categories)
                    .range(weights);


            function data() {
                var labels = color.domain();
                return labels.map(function (label) {
                    return {label: label, value: weight(label)};
                });
            }

            change(data());


            function change(data) {

                /* ------- PIE SLICES -------*/
                var slice = svg.select(".slices").selectAll("path.slice")
                        .data(pie(data), key);

                slice.enter().insert("path")
                        .style("fill", function (d) {
                            return color(d.data.label);
                        })
                        .attr('filter', 'url(#pieChartInsetShadow)')
                        .attr("class", "slice")
                        .attr("d", function (d) {
                            this._current = this._current || d;
                            var interpolate = d3.interpolate(this._current, d);
                            this._current = interpolate(0);
                            return arc(interpolate(d.value));
                        });

                slice.exit().remove();

                /* ------- TEXT LABELS -------*/


                function midAngle(d) {
                    return d.startAngle + (d.endAngle - d.startAngle) / 1.5;
                }

                var text = svg.select(".labels")
                        .selectAll("text")
                        .data(pie(data), key);

                function isPositionFalse(posY, cache) {
                    for (var key in cache) {
                        var position = cache[key];
                        if (Math.abs(posY - position) < 12) {
                            return true;
                        }
                    }
                    return false;
                }

                var cacheText = [];

                text.enter().append("text")
                        .attr("dy", ".35em")
                        .text(function (d) {
                            return d.data.label;
                        })
                        .attr("transform", function (d) {
                            this._current = this._current || d;
                            var interpolate = d3.interpolate(this._current, d);
                            this._current = interpolate(0);

                            var d2 = interpolate(d.value);
                            var pos = outerArc.centroid(d2);

                            var posX = radius * (midAngle(d2) < Math.PI ? 1 : -1);
                            var posY = pos[1];

                            var difference = 0;
                            while (isPositionFalse(posY, cacheText)) {
                                posY = posY + 3;
                            }

                            cacheText.push(posY);

                            return "translate(" + posX + ", " + posY + ")";
                        })
                        .attr("text-anchor", function (d) {
                            this._current = this._current || d;
                            var interpolate = d3.interpolate(this._current, d);
                            this._current = interpolate(0);
                            var d2 = interpolate(d.value);
                            return midAngle(d2) < Math.PI ? "start" : "end";
                        })
                ;

                text.exit().remove();


                /* ------- SLICE TO TEXT POLYLINES -------*/

                var polyline = svg.select(".lines")
                        .selectAll("polyline")
                        .data(pie(data), key);

                var cachePolyLine = [];

                polyline.enter().append("polyline")
                        .attr("points", function (d) {
                            this._current = this._current || d;
                            var interpolate = d3.interpolate(this._current, d);
                            this._current = interpolate(0);
                            var d2 = interpolate(d.value);
                            var pos = outerArc.centroid(d2);
                            pos[0] = radius * 0.95 * (midAngle(d2) < Math.PI ? 1 : -1);


                            var posMid = outerArc.centroid(d2);
                            while (isPositionFalse(pos[1], cachePolyLine)) {
                                pos[1] = pos[1] + 3;
                                posMid[1] = posMid[1] + 3;
                            }

                            cachePolyLine.push(pos[1]);


                            return [arc.centroid(d2), posMid, pos];
                        })
                ;

                polyline.exit().remove();
            };


        })("#statistic_user_focus");
    });
</script>